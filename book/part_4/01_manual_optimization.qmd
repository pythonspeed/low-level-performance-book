# Manually optimize floating-point calculations

```{python}
# Import the dependencies we'll need:
import numpy as np
from numba import njit
```

```{python}
#| echo: false
%load_ext book_magics
```

## ILP

```{python}
generator = np.random.default_rng(0)
SIZES_INCHES = generator.uniform(1, 10, (1_000_000, 3)).astype(np.float32)

@njit
def volume_liters(sizes):
    result = np.empty((sizes.shape[0],), dtype=np.float32)
    for i in range(sizes.shape[0]):
        width, height, depth = sizes[i][0], sizes[i][1], sizes[i][2]
        result[i] = (width * 2.54 * height * 2.54 * depth * 2.54) / 1000.0
    return result

result = volume_liters(SIZES_INCHES)

@njit
def volume_liters_2(sizes):
    result = np.empty((sizes.shape[0],), dtype=np.float32)
    in3_to_cm3 = 2.54 * 2.54 * 2.54
    for i in range(sizes.shape[0]):
        width, height, depth = sizes[i][0], sizes[i][1], sizes[i][2]
        result[i] = (width * height * depth * in3_to_cm3) / 1000.0
    return result

result_2 = volume_liters_2(SIZES_INCHES)
```


```{python}
#| echo: false
%%compare_timing
volume_liters(SIZES_INCHES)
volume_liters_2(SIZES_INCHES)
```

```{python}
print(np.array_equal(result, result_2))
print(np.abs(result - result_2).mean())
```

## Division into multiplication

```{python}
@njit
def volume_liters_3(sizes):
    result = np.empty((sizes.shape[0],), dtype=np.float32)
    in3_to_liter = 2.54 * 2.54 * 2.54 / 1000.0
    for i in range(sizes.shape[0]):
        width, height, depth = sizes[i][0], sizes[i][1], sizes[i][2]
        result[i] = width * height * depth * in3_to_liter
    return result

result_3 = volume_liters_3(SIZES_INCHES)
print(np.abs(result - result_3).mean())
```

```{python}
#| echo: false
%%compare_timing
volume_liters_2(SIZES_INCHES)
volume_liters_3(SIZES_INCHES)
```

