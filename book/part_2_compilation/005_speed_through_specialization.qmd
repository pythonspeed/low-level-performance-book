# Replace Python interactions with compiled code âžŠ

```{python}
#| echo: false
%load_ext book_magics
```


## Use static typing to generate a specialized data structure

Consider finding the most frequently occurring value in a list of integers.

Here's a pure Python version:

```{python}
from collections import Counter

def most_frequent_py(values):
    counts = Counter()
    for value in values:
        counts[value] += 1
    result = None
    max_count = 0
    for (value, count) in counts.items():
        if count > max_count:
            max_count = count
            result = value
    return result
```

Next, I'll do a one-to-one translation to a compiled language.
For this chapter I'm going to be using Rust, because Rust has a much richer set of data structures than Numba, which will come in handy.

```{python}
#| echo: false

# The `rustimport` library lets you import a Rust files and crates directly
# from Python, recompiling automatically if they change. See
# https://pythonspeed.com/articles/easiest-rust-python/ for a walkthrough.
import rustimport.import_hook
# Compile in release mode, for full performance; Rust compiles in development
# mode by default which is much slower to run.
import rustimport.settings
rustimport.settings.compile_release_binaries = True
```

Here's the closest thing to a one-to-one translation Rust; it stores Python objects in a Rust `HashMap`, using their hashing and equality.
So it's still doing a significant number of interactions with Python objects for every value tracked by the `HashMap`:

```{rust}
// TODOs
```

This implementation gives the same results:

```{python}
import random
import frequent_rs

DATA = [random.randint(0, 1000) for _ in range(100_000)]

assert frequent_rs.most_frequent_naive(DATA) == most_frequent_py(DATA)
```

Here's how their speed compares:

```{python}
#| echo: false
%%compare_timing
most_frequent_py(DATA)
frequent_rs.most_frequent_naive(DATA)
```

So that's faster, I suspect because there's a bit less overhead in iteration, but also because all the math incrementing counters doesn't have Python overhead at all.
But we can do better.

```{python}
#| echo: false
%%compare_timing
most_frequent_py(DATA)
frequent_rs.most_frequent_optimized(DATA)
```
