---
filters:
   - include-code-files
---
# Replace Python interactions with compiled code âžŠ

You can speed up your program by replacing Python code with compiled code.
But there are different levels of replacement: you can write compiled code that still heavily interacts with Python objects, and all these interactions will still be slower than interactions with non-Python objects.

In this chapter then I'll demonstrate making compiled code repeatedly faster by reducing interactions with Python.

```{python}
#| echo: false
%load_ext book_magics
```

## Example: Finding the most frequent value in a Python list

Consider finding the most frequently occurring value in a list of integers.

Here's a pure Python version:

```{python}
from collections import Counter

def frequent_py(values: list[int]) -> int:
    counts = Counter()
    for value in values:
        counts[value] += 1
    result = None
    max_count = 0
    for (value, count) in counts.items():
        if count > max_count:
            max_count = count
            result = value
    return result
```

## Reduce overhead of dynamic lookups

Next, I'll do a one-to-one translation to a compiled language.
For this chapter I'm going to be using Rust, because Rust has a much richer set of data structures than Numba, which will come in handy.

```{python}
#| echo: false
import os

# The `rustimport` library lets you import a Rust files and crates directly
# from Python, recompiling automatically if they change. See
# https://pythonspeed.com/articles/easiest-rust-python/ for a walkthrough.
import rustimport.import_hook
import rustimport.settings

# Compile in release mode, for full performance; Rust compiles in development
# mode by default which is much slower to run.
rustimport.settings.compile_release_binaries = True
# Recompile each time we import the module (seems broken sometimes, might have
# issues due to Jupyter caching):
rustimport.settings.force_rebuild = True

# Don't output from Rust compiler:
os.environ["CARGO_TERM_QUIET"] = "true"
```

Here's the closest thing to a one-to-one translation Rust; it will do all the operations using Python dictionaries and Python integers.
In practice this sort of code is better written with Cython, or perhaps compiled with `mypyc`, but using Rust will be helpful in later iterations on this code.

```{.rust include="frequent_rs/src/lib.rs" snippet="one_to_one"}
```

This implementation gives the same results:

```{python}
import random
import frequent_rs

DATA = [random.randint(0, 1000) for _ in range(100_000)]

assert frequent_py(DATA) == frequent_rs.one_to_one(DATA)
```

Here's how their speed compares:

```{python}
#| echo: false
%%compare_timing
frequent_py(DATA)
frequent_rs.one_to_one(DATA)
```

So that's faster, I suspect because there's a bit less overhead in iteration.

## Use static typing for faster math and faster specialized data structure

The above code can still be sped up:

1. Swap out Python integer math for native math in Rust.
2. Swap out using a Python dictionary for a Rust `HashMap`, and in particular a `HashMap` that is specifically compiled to store just `i64` and nothing else.

```{.rust include="frequent_rs/src/lib.rs" snippet="rust_calculations"}
```

```{python}
assert frequent_py(DATA) == frequent_rs.rust_calculations(DATA)
```

```{python}
#| echo: false
%%compare_timing
frequent_py(DATA)
frequent_rs.rust_calculations(DATA)
```

## Bypass Python objects altogether

```{.rust include="frequent_rs/src/lib.rs" snippet="numpy"}
```

```{python}
import numpy as np

DATA_NUMPY = np.array(DATA, dtype=np.int64)

assert frequent_py(DATA) == frequent_rs.numpy(DATA_NUMPY)
```

```{python}
#| echo: false
%%compare_timing
frequent_py(DATA)
frequent_rs.numpy(DATA_NUMPY)

```
