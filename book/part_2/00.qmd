# Switch to compiled code

So far the optimizations we've covered are language-agnostic: you can apply them whether you're writing Python, Rust, or JavaScript.
But if you're currently writing Python, eventually you will encounter a situation where your code runs too slowly, and you'll need to switch to a faster, compiled language.

Examples of compiled languages include C, C++, Rust, Fortran, and Numba.
For all of these:

1. Before the code can be run, the code is converted ("compiled") to machine code using a tool called a "compiler".
   Machine code is the set of binary instructions your CPU runs.
   By generating machine code, the compiled output can run directly on the CPU, without any additional software-based translations.
2. In most cases, the compiler knows each variable's specific type at compile time.
   It might be a 64-bit integer, it might be something more complex, but this information is available to the compiler.
   Some languages providing higher-level features that loosen this restriction, but the most common case (templates in C++, generics in Rust) just mean temporarily delaying this knowledge to a later stage in the compilation process.

Cython is another compiled language you can use, with an extra stage of initial compilation: first it is compiled into C or C++, and then the C/C++ code is compiled to machine code.

Over the next few chapters, we'll see how compilation generates code that can run quickly, and how that impacts the way you write your code.
