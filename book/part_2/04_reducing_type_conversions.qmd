# Choose appropriate variable types

```{python}
#| echo: false
%load_ext book_magics
```

Knowing the types of variables can help the compiler generate efficient machine code.
For example, your CPU has a machine code instruction for adding two 64-bit integers, so if the compiler knows that's what being added, it can generate that directly.
Compare this to normal Python, where integers can be arbitrarily large, so adding integers has to support additional cases, like adding two numbers that are too big fit in 64-bits.

Depending on the compiled language, the types of variables might always be explicit, for example in C:

```c
int add(int a, int b) {
  return a + b;
}
```

In Rust, arguments to functions are always explicit, but variable types can often be automatically deduced:

```rust
fn add(a: i64, b: i64) -> i64 {
    let result = a + b;  // result is also i64
    result  // return the result
}
```

In Numba, the types are discovered from the inputs and by rules that determine what the default types are when there is ambiguity:

```{python}
import numpy as np
from numba import jit

@jit
def add(a, b):
    return a + b

add(np.int32(1), np.int16(2))

# Tell Numba to print out the types being used in its calculation:
add.inspect_types()
```

As you can see, Numba's default for integer variables is 64-bit signed integers, the equivalent of `numpy.int64`.

## Pick smaller integer data types when possible

Unlike Python, which only has one integer and one float data type, compiled languages have a range of options.
For integers there are 8-bit, 16-bit, 32-bit, and 64-bit integers (and sometimes 128-bit), and each comes in signed and unsigned versions.
Signed types can support negative numbers, whereas unsigned types only support positive numbers.

For example:

* 8-bit signed integers range from -128 to 127.
* 16-bit unsigned integers range from 0 to 65,535.

Which one should you use?
At minimum, you need to fit your data into the data type.
If you need to store `123001`, you can't use 8-bit or 16-bit integers: the number simply won't fit.
So one easy approach is to always use 64-bit integers.

However, when storing large numbers of values, this results in higher memory usage:

```{python}
print("How much memory (in bytes) is used by an array with 1,000,000 values?")
print("int8: ", np.ones((1_000_000), dtype=np.int8).nbytes)
print("int16:", np.ones((1_000_000), dtype=np.int16).nbytes)
print("int32:", np.ones((1_000_000), dtype=np.int32).nbytes)
print("int64:", np.ones((1_000_000), dtype=np.int64).nbytes)
```

Using more memory means you're more likely to run out of RAM.
But also due to the limited size of CPU's memory caches, using more memory can also result in code running more slowly; we'll cover these caches in a later chapter.
So if you have a large number of integer values between 0 and 100, sticking to 8-bit or 16-bit integers may be worth it.

## Remove implicit type conversions in inner loops

What happens if you want to do some mathematical operation involving two variables of different types?
This depends on the programming language you're using.
In Rust, for example, type conversions typically have to be done explicitly.
In contrast, Numba and some other compiled languages type conversions implicitly.

Type conversions (implicit or explicit) can both force the compiler to generate more code, or prevent it from applying certain optimizations.
So if this conversion is happening in a performance-critical inner loop, you can sometimes get faster performance by being more explicit, and choosing an option that uses less work.

Let's look at an example; we have a microscope image of a cell:

```{python}
from skimage import io
from skimage.data import cell

IMAGE = cell()
assert IMAGE.dtype == np.uint8
```

```{python}
#| echo: false
%display_image IMAGE
```

We want to threshold the image, separating the image into two parts, the bright part and the dark part.
This is a useful operation to find the shapes of objects.
A naive algorithm for thresholding is comparing each pixel to the mean of the image.

As a first pass, we can write an implementation using Numba.
Because we're accumulating a large number of `uint8`s to create the total used to calculate the mean, we need to store it in a larger type, so we'll use a `float64`:

```{python}
@jit
def mean_threshold_1(image):
    # Lacking an explicit type, by default Numba will make `total` an int64:
    total = 0
    for y in range(image.shape[0]):
        for x in range(image.shape[1]):
            total += image[y, x]
    # The mean is the threshold; division in Numba gives us floats, so
    # `threshold` will be a `float64`:
    threshold = total / image.size
    # Store whether or not each value is larger than the threshold:
    result = np.empty(image.shape, dtype=np.uint8)
    for y in range(image.shape[0]):
        for x in range(image.shape[1]):
            # The >= expression becomes either 0 or 1:
            result[y, x] = (image[y, x] >= threshold) * 255
    return result

THRESHOLD_1 = mean_threshold_1(IMAGE)
```

And here's what the result looks like:

```{python}
#| echo: false
%display_image THRESHOLD_1
```

There are multiple implicit type conversion happening in the code beyond the one explained in the code comments.
Can you find them?

::: {.callout-tip collapse="true"}
## Expand to see the answer
1. `total += image[y, x]` is adding an `int64` and a `uint8`.
2. `image[y, x] >= threshold` is comparing a `uint8` and a `float64`.
:::

Focusing on the second conversion, there are at least two ways the comparison might happen:

* `image[y, x]` is converted to a `float64` so both values are `float64`, which means doing extra work on every loop iteration.
* `threshold` is converted to a `uint8` so both values are `uint8`, in which case hopefully the compiler will hoist the conversion out of the loop.

Or perhaps the implementation might happen some other way; perhaps the compiler might be able to compare a `uint8` and `float64` without any conversion.
Nonetheless, rather than hoping that any repetitive work is hoisted out of the loop, can try explicitly casting to `uint8` ourselves outside of the loop:

```{python}
from numba import uint8

@jit
def mean_threshold_2(image):
    total = 0
    for y in range(image.shape[0]):
        for x in range(image.shape[1]):
            total += image[y, x]
    # ðŸ˜Ž Convert the mean to an uint8 before we do the comparison:
    threshold = uint8(np.round(total / image.size))

    result = np.empty(image.shape, dtype=np.uint8)
    for y in range(image.shape[0]):
        for x in range(image.shape[1]):
            result[y, x] = (image[y, x] >= threshold) * 255
    return result

THRESHOLD_2 = mean_threshold_2(IMAGE)
assert np.array_equal(THRESHOLD_1, THRESHOLD_2)
```

This new version is significantly faster:

```{python}
#| echo: false
%%compare_timing --measure=instructions
mean_threshold_1(IMAGE)
mean_threshold_2(IMAGE)
```
