# Our software is slow—but it doesn't have to be! {.unnumbered}

Modern computers are unimaginably fast, but quite a lot of software is annoyingly slow.
And slow software has a cost beyond mere annoyance: it costs money, time, frustration, not to mention greenhouse-gas emissions.
So if computers are so fast, why isn't software faster by default?

Sometimes the slowness is a considered choice, with the programmer deliberately choosing to prioritize some other goal at the expense of speed, like ease-of-use or flexibility.
But sometimes the slowness is the result of the programmer not noticing or not realizing they were writing slow code.
I've certainly made these sort of mistakes.

I believe that this second reason is much more common: most software is unnecessarily slow, and we all can and should do better.
As a result, my goal with this book isn't just to help you speed up software that you know is unacceptably slow.
My goal is also to help you write software that is fast from the start, by default.

## Five practices to speed up your Python software

If you're going to write faster software, you need to understand the different computational bottlenecks that keep your code slow, and correspondingly the different techniques you can use speed to it up.
It's helpful to organize these techniques into _practices_: each practice is a set of techniques that provide a distinct source of speed.
Because they are distinct, you can apply multiple practices to get even more speed.
For the purposes of this book, I will be covering five practices.

First, there are some techniques to speed up your code that work no matter what programming language you're using.
I call this the **Practice of Algorithmic Efficiency**: your code shouldn't waste time recalculating work, or calculating things you don't care about.

Second, as a Python programmer, you face an additional bottleneck, Python itself.
So a common way to speed Python code is with the **Practice of Compilation**, switching to a compiled language to write a Python extension.

Importantly, a compiler can't always make your code as fast as you'd like.
For example, compilers are much worse at optimizing float calculations compared to integer calculations.
So if you want to make your code as fast as possible, it's not enough to just switch to a compiled language.
You also need to know the limits of what the compiler can do.

Third, because Python is so slow, you can get away with a simple mental model of how CPUs work.
But once you switch to a compiled language, hardware features like instruction-level parallelism and branch prediction can significantly impact your code's speed.
Writing code that takes advantage of the CPU—and doesn't fight it—is what's involved in the **Practice of Mechanical Sympathy**.

Fourth, there's all the many cores in your CPU: you want to use all of them.
This is the **Practice of Parallelism**.

Finally, it's worth considering that software development isn't just about your code, it's also about your software development processes.
When it comes to correctness it's common practice, for example, to prevent code from being merged until its tests pass.
Similarly, good development processes are necessary if you want your software to stay fast: the **Practice of Process**.

> What about GPUs?
> This book doesn't cover GPUs at all, but the same practices, with somewhat different techniques, apply there as well.
> It's also worth keeping in mind that a lot of software is slow not because it's running on a CPU, but because it's written in a vastly inefficient way.
> Which means you might be able to achieve a two or three orders of magnitude speedup even without switching to a GPU.

## By your powers combined

This book will introduce you to, and is organized around, these five practices.
Each one of these practices can make your code faster _in a distinct way_, because each relies on different approaches and mechanisms.
So while you can just start with one, you can often apply multiple practices to go even faster.

When the five practices combine, the full power of the computer can be yours!
