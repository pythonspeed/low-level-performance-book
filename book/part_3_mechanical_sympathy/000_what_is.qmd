# What is the Practice of Mechanical Sympathy?

Consider the following situation: Jo is on a bike, stopped at a traffic light.
When it's their turn to go, they start pedaling, and they realize they're in a high gear, which means it takes lots of extra effort to get moving.
And this _keeps happening_ every time they start biking from a stop in an intersection.

Why aren't they in the correct, low gear?

1. When approaching an intersection, they're probably going at a decent speed, so they will be in a high gear.
2. They stop at the traffic light, still in a high gear.
3. If they have a bike with a derailleur, the default where I live, changing gears _requires pedaling_.
   But they've already stopped, so now they're stuck with the wrong gear.

To solve this problem, they need to adjust their behavior to the way the bicycle works.
As they approach the intersection, they need to start lowering their gears, so by the time they've stopped they are in the correct low gear to easily start biking again.

As with bicycles, so with computers:

* If your mental model of how the CPU works is missing certain critical behaviors, you will end up writing code that is in conflict with the way the CPU was designed to work.
  Your code will still run, but it will be slower than it needs to be.
* On the other hand, as you improve your mental model of the CPU, you can write code that not only doesn't fight the CPU, but also takes advantage of the CPU's fast paths.

This is the Practice of Mechanical Sympathy.

### Next steps {.unnumbered}

The next few chapters will cover various features of CPUs that you can take advantage of—or at least avoid fighting with—to speed up your code.
Then, the next section will take about some hardware features involving memory that can impact software performance.
