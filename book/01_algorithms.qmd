# Use a scalable algorithm

How long it takes your program to run depends on two sets of decisions embedded in your code:

1. The choice of algorithm.
2. The implementation.
   For example, as we'll be repeating repeatedly, low-level languages like C can run the same algorithm much faster than Python can.

In the rest of the book we'll focus on the implementation, but in this chapter we'll focus on choice of algorithm.

```{python}
#| echo: false
%load_ext book_magics
```

## The 

How long your program runs depends on the size of the input: processing a 1,000,000-base DNA sequence will probably take longer than processing a 1,000-base sequence.
And once you're dealing with large input sizes, an algorithm that scales badly will be so slow that your implementation speed won't matter.

Let's consider an example: quadratic algorithms, which are very easy to write accidentally, to the point that there is [a blog showcasing examples](https://accidentallyquadratic.tumblr.com/).
A typical mistake is to have a loop, and then call a function that doesn't look like a loop but actually causes another loop over the same data.
Here's an example from the blog, with just pure Python, calculating the intersection of two lists of length `N`:

```{python}
def slow_algorithm(l1, l2):
    result = []
    # This has N steps:
    for item in l1:
        # Checking if an item is contained in a list requires N comparisons:
        if item in l2:
            result.append(item)
    return result

def fast_algorithm(l1, l2):
    result = []
    l2_as_set = set(l2)
    for item in l1:
        # Checking if an item is contained in a Python set takes a fixed amount
        # of time:
        if item in l2_as_set:
            result.append(item)
    return result

DATA = list(range(1_000))
DATA2 = list(range(3, 1_003))
assert slow_algorithm(DATA, DATA2) == fast_algorithm(DATA, DATA2)
```

The second implementation is much faster:

```{python}
#| echo: false
%%compare_timing
slow_algorithm(DATA, DATA2)
fast_algorithm(DATA, DATA2)
```

## Big O notation is a way of modeling algorithm scalability

Let's compare 
The `slow_algorithm()` above does $N^{2}$ operations: for each item in the first list it may need to iterate over every item in the second list.
So assuming both lists are of size $N$, that's $N^{2}$ operations.

## A fast implementation is useless if your algorithm doesn't scale
