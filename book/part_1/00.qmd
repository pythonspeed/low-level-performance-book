# Reduce how many CPU instructions your code uses

When it comes to writing correct software, the only thing that matters are the results of your calculations.
If you add 2 and 3 and get back 5, that's all you care about.
But if you care about speed, implementation details do matter: adding 2 and 3 in C++ is going to be a lot faster than doing so in Python.
And since all your code runs on a CPU, this implies you need to understand how CPUs works if you want to write fast code.

There's a problem with this approach: modern CPUs have billions of transistors.
No human being, even the chips' designers, can truly comprehend _exactly_ how they work.
But luckily, to write fast software you don't need to understand everything about how the CPU works, you just need a reasonable mental model.

We'll start with a very simplistic and inaccurate model of how a CPU works:

1. A CPU core sequentially executes a series of machine code instructions.
   An instruction might add two numbers, or read a value from RAM.
2. Only one instruction is executed at a time.
3. Each instruction takes approximately the same amount of time to execute.

In later chapters we'll switch to a more realistic—but still inaccurate!—mental model.
But even this simplistic model is useful.
It tells us that if we want our software to run faster, one way to do so is to use fewer CPU instructions.
We can do this in one of two ways:

1. Figuring out a more efficient way to get the same results.
2. Accepting somewhat different results in exchange for running fewer instructions.

