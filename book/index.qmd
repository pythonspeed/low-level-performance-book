# Introduction {.unnumbered}

There are many kinds of software you can write: web applications, video games, scientific computing, and much more.
This book doesn't address all these types of software.
Instead, this book is specifically written for scientists, data scientists, and software developers who use Python to do numeric computing or data processing.

Even with that limited focus, there are still many potential reasons your software might be slow.
Your bottleneck might be computation, or network latency, or disk bandwidth.
Once again, this book won't cover all of these.
There are other books that cover performance from a much broader perspective than this one:

* [_High Performance Python, 2nd edition_](https://www.oreilly.com/library/view/high-performance-python/9781492055013/), by Gorelick and Oszvald.
  A third edition is in the works; I will likely be contributing a tiny section on Rust.
* [_Fast Python_](https://www.manning.com/books/fast-python), by Antao.

This book limits itself to one particular subset of the performance problem: computation.
In particular, I'm assuming that you have:

1. Determined that the speed of your code is a problem worth addressing.
2. Profiled your code to find the key bottleneck.
3. Discovered the bottleneck is computation, i.e. the amount of CPU time the code uses.
   If the bottleneck was something else, like network latency, this book won't help.

I do a quick review of this process, and the bigger picture of performance, at the end of the book; if you're not familiar with the process, you may wish to [start by reading that section first](part_9/01_when.qmd), and then return to the beginning of the book.
The two books mentioned above should also be helpful.

Assuming your performance bottleneck is computation, how do you speed it up?

## Speeding up Python-based data processing computation

Python[^cpython] is notoriously slow, but often used to handle large-scale data processing.
In order to do so in a reasonable amount of time, the solution has traditionally involved writing Python extensions in a fast, low-level, compiled language: C, C++, Fortran, Cython, Numba, Rust, and others.

There are many pre-existing compiled extensions available as free libraries: NumPy, SciPy, Pandas, and Polars, to name just a few.
If those libraries are fast enough for you, no need to read the rest of this book!

Sometimes, however, preexisting libraries aren't fast enough, or aren't memory efficient enough, or simply don't implement the algorithms you need.
In that case, the common advice you will get is:

1. Re-write your code in a compiled language.
2. Then, take advantage of parallelism, using multiple CPU cores.

Unfortunately, there's a key step missing in the middle of this process, a step that is the main focus of this book.

## The missing step: optimization

There's a better plan for speeding up your computational code:

1. Re-write your code in a compiled language.
2. **Optimize your code.**
   This is what we'll focus on in this book.
3. Then, take advantage of parallelism, using multiple CPU cores.

Why not jump straight to parallelism?

Imagine you've done step 1, and you still need to make your code 100× faster.
If you're going to rely on parallelism, you will need to use 100 CPU cores, which can be very expensive, whether you're running in the cloud or buying a local machine.
You might also need to switch to a solution that involves multiple machines, which makes your software that much more complex.

If, however, you can optimize your code first and make it 10× faster, you only need to use 10 CPU cores to reach that final 100× speedup.
That means you've dropped the financial cost of computing by 90%.
It also means you can stick to running on a single machine, which means much simpler software.

In short, a little time spent on optimization can result in major time and financial savings.

## Reading the book

Most of the examples in this book will use the Numba language and compiler, because it is easy to install and uses the same syntax as Python.
However, this is not a book about Numba: the concepts the book covers also apply to C, C++, Cython, Rust, and other low-level languages.
I will discuss the functionality of these other languages where relevant.

If you like starting with the big picture, you might want to [jump to the last part of the book](part_9/01_when.qmd) and then jump back to the beginning of the book.
Otherwise, let's leap right in to speeding up your computation.

[^cpython]: Technically, it's not the language that's slow, it's the default implementation. To distinguish the two, the Python interpreter is often known as CPython. The PyPy interpreter is a different implementation of the language that can do math much faster, but it adds overhead when interoperating with NumPy and other similar libraries, and lags behind on language features.
